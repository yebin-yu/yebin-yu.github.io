### 基础

#### 讲基础的，基础的网络/系统这些，可以多看看回顾一下，查漏补缺

[图解网络](https://www.xiaolincoding.com/network/)

[图解系统](https://www.xiaolincoding.com/os/)

[图解 MySQL](https://www.xiaolincoding.com/mysql/)

[图解 Redis](https://www.xiaolincoding.com/redis/)



#### MQ（Message Queue）优秀博客分享

[MQ系列1：消息中间件执行原理](https://www.cnblogs.com/wzh2010/p/15888498.html)

[MQ系列2：消息中间件的技术选型 ](https://www.cnblogs.com/wzh2010/p/15311174.html)

[MQ系列3：RocketMQ 架构分析](https://www.cnblogs.com/wzh2010/p/16556570.html)

[MQ系列4：NameServer 原理解析](https://www.cnblogs.com/wzh2010/p/16607258.html)

[MQ系列5：RocketMQ消息的发送模式](https://www.cnblogs.com/wzh2010/p/16629876.html)

[MQ系列6：消息的消费](https://www.cnblogs.com/wzh2010/p/16631097.html)

[MQ系列7：消息通信，追求极致性能](https://www.cnblogs.com/wzh2010/p/16631103.html)

[MQ系列8：数据存储，消息队列的高可用保障](https://www.cnblogs.com/wzh2010/p/16631107.html)

[MQ系列9：高可用架构分析](https://www.cnblogs.com/wzh2010/p/15888521.html)

[MQ系列10：如何保证消息幂等性消费](https://www.cnblogs.com/wzh2010/p/15888523.html)

[MQ系列11：如何保证消息可靠性传输](https://www.cnblogs.com/wzh2010/p/15888525.html)

[MQ系列12：如何保证消息顺序性](https://www.cnblogs.com/wzh2010/p/15888528.html)

[MQ系列13：消息大量堆积如何为解决 ](https://www.cnblogs.com/wzh2010/p/15888534.html)



#### 继上一个MQ的，同一个博主

[Java核心知识1：泛型机制详解](https://www.cnblogs.com/wzh2010/p/15886611.html)

[Java核心知识体系2：注解机制详解](https://www.cnblogs.com/wzh2010/p/15886622.html)

[Java核心知识体系3：异常机制详解](https://www.cnblogs.com/wzh2010/p/15886635.html)

[Java核心知识体系4：AOP原理和切面应用](https://www.cnblogs.com/wzh2010/p/15886644.html)



### 详细

还在无脑用 StringBuilder？来重温一下字符串拼接吧

https://juejin.cn/post/7182872058743750715

```markdown
讲了实现 “A” + “B” + “C” 底层逻辑，根据Java的版本来分析最优策略。

# Java9之前
字符串拼接是用StringBuilder实现的，会new一个StringBuilder来拼接字符串，然后通过toString返回。第一个弊端是会创建多余的对象，第二个弊端是append的时候StringBuilder会不断扩容，多次内存分配导致性能变差。

# Java9
#### Indify String Concatenation
改成了JVM 会生成对应的负责拼接字符串的函数，函数内部可以进行各种优化。
JVM 在执行到 InvokeDynamic 指令时会自动使用 makeConcatWithConstants 优化，生成一个对应的 CallSite 对象，用优化过的 CallSite 对象对字符串进行拼接。此后此处所有的字符串拼接都会使用同一个 CallSite 对象。

优点：
1. int等基础类型的值不会被Boxing之后再Unboxing，而是用动态生成的函数直接拼接。
2. 具体实现不清楚，但可能是创建StringBuilder的基础上，增加了大小，也就是 new StringBuilder(a.size() + ...)，速度和内存消耗都有提升


#### 字符串压缩
ASCII只要用1byte，如果全是ASCII，则能节省一半的空间。

缺点：
1. StringBuilder还是默认会对字符串的byte做压缩，中文无法压缩，所以中文的话每次都要分配两次内存，至今（Java19），StringBuilder都没有对此做优化。

# Java 15
削减了一些 Indify String Concatenation 的一些性能不佳的策略。
实现大概为：`需要一次复制的策略：我们先准确分配好 a + b + c 所需的空间，把 a, b, c 的内容复制到我们分配的空间里， 最后直接把我们分配的空间通过内部 API 传给字符串。`
```







