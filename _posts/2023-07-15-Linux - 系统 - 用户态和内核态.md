---
layout:     post
title:      Linux - 系统 - 用户态和内核态
subtitle:   啥叫用户态内核态？为啥需要这个？
date:       2023-07-15
author:     yebin-yu
header-img: img/tag-bg.jpg
catalog: false
tags:
    - Linux 系统
---

# Linux - 系统 - 用户态和内核态

- [Linux - 系统 - 用户态和内核态](#linux---系统---用户态和内核态)
    - [什么是内核态？为什么需要内核态？](#什么是内核态为什么需要内核态)
    - [用户态如何调用内核态的指令呢？](#用户态如何调用内核态的指令呢)
    - [用户态和内核态切换的开销](#用户态和内核态切换的开销)
    - [用户态切换内核态的三种方式](#用户态切换内核态的三种方式)
    - [参考链接](#参考链接)

### 什么是内核态？为什么需要内核态？

为了安全。

有些CPU的指令集比较危险，比如直接操作硬件的，会影响整个系统的正常运作。

> 想象一下，有个进程向操作系统发送：“帮我unmount根目录”

硬件设备商直接提供硬件级别的支持，做法就是对 CPU 指令集设置了权限，不同级别权限能使用的 CPU 指令集 是有限的，以 Intel CPU 为例，Intel把 CPU 指令集 操作的权限由高到低划为4级：

```
ring 0
ring 1
ring 2
ring 3
```

其中 ring 0 权限最高，可以使用所有 CPU 指令集，ring 3 权限最低，仅能使用常规 CPU 指令集，不能使用操作硬件资源的 CPU 指令集，比如 IO 读写、网卡访问、申请内存都不行。

Linux系统仅采用ring 0 和 ring 3 这2个权限。其中ring 0就是内核态，ring3 就是用户态。



### 用户态如何调用内核态的指令呢？

所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等. 而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作.

这时需要一个这样的机制: 用户态程序切换到内核态, 但是不能控制在内核态中执行的指令

这种机制叫**系统调用**, 在CPU中的实现称之为**陷阱指令**(Trap Instruction)

他们的工作流程如下:

```
1. 用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈(stack frame), 以此表明需要操作系统提供的服务.
2. 用户态程序执行陷阱指令
3. CPU切换到内核态, 并跳到位于内存指定位置的指令, 这些指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问
4. 这些指令称之为陷阱(trap)或者系统调用处理器(system call handler). 他们会读取程序放入内存的数据参数, 并执行程序请求的服务
5. 系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果
```

当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。 



### 用户态和内核态切换的开销

- 保留用户态现场（上下文、寄存器、用户栈等）
- 复制用户态参数，用户栈切到内核栈，进入内核态
- 额外的检查（因为内核代码对用户不信任）
- 执行内核态代码
- 复制内核态代码执行结果，回到用户态
- 恢复用户态现场（上下文、寄存器、用户栈等）



### 用户态切换内核态的三种方式

- 系统调用

```
这是用户态进程主动要求切换到内核态的一种方式。
用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用。
而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。
```

- 中断

```
当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序。
如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。
比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
```

- 异常

```
当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号。
这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，
如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。
比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
```

> 从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态的步骤主要包括：
>
> [1] 从当前进程的描述符中提取其内核栈的ss0及esp0信息。
>
> [2] 使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。
>
> [3] 将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。



### 参考链接

[从根上理解用户态与内核态](https://juejin.cn/post/6923863670132850701)

[用户态和内核态的区别](https://blog.csdn.net/youngyoungla/article/details/53106671)
